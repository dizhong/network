High-level approach:

There are five files for this homework. 
The rawhttpget file has the main function for the general logic of handling input parameter, creating socket and connection for download accordingly, and save the downloaded data to a file in the disk.
The connection.py file tries to mimic the actual socket in python. The connection class maintains a lot of states relevant to the TCP connection, and has a number of functions including send() and recv() that mostly tries to do what socket.send() and socket.recv() does in python, though not exactly the same. The most important difference is that 3-way handshake is implemented with send()  and recv_pkt(), which is I think different from what python socket automatically does. I replicated what the socket.recv() does in returning data for the recv() function in connection.py, which is if the function returns with b'', it means that the connection has been ended, otherwise block and wait for more data.
 The actual handling of tcp and http headers are in tcp_handle.py and ip_handle.py respectively. These two files handle the creation of ip/tcp headers, and the parsing of ip/tcp headers.
 Once the ip/tcp headers are processed and the packet verified correct, the rest of the data from the packet (if any) gets passed to the http layer, namely the http_handle.py file. This file is basically the exact same code from the webcrawler homework reused. It checks if http data is in chunked encoding, and then receives the data accordingly.
 
 Notice that if this code need to be tested multiple times, I recommend to comment out lines 37~38 in rawhttpget, and uncomment line 41, so that for each execution of the program, it selects a random port in a range of big numbers, which does not *guarantee* the port is available but good for testing purpose.



TCP/IP features:

Implemented functions for composting TCP header and IP header respectively. Made sure of correct sequence numbers and acks. Handles TCP connection setup and teardown. Looks at packet headers and filter out the ones that do not belong to the current connection. Has timeout for when server stops responding. Only acks for the packets that need to be acked (aka all the packets other than the ack-only ones).

Setts the correct version, header length and total length, protocol identifier, and checksum in each outgoing packet. Correctly sets the source and destination IP in each outgoing packet. Uses existing OS APIs to query for the IP of the remote HTTP server as well as the IP of the source machine. Selects the correct IP address of the local machine. Checks the validity of IP headers from the remote server. 
Generates correct checksums for outgoing packets. Selects a valid local port to send traffic on, perform the three-way handshake, and correctly handle connection teardown. Your code must correctly handle sequence and acknowledgement numbers. Make sure packts are in correct order before delivering them to the higher-level, HTTP handling code. Identifies and discards duplicate packets.



Challenges:

There were a lot of challenges for doing this assignment. One of the biggest lessons learned is that I am much worse at reading specs than I thought I was..

The first big obstacle was which parameters to pass into the creation function call of the recv socket. At the time when I started doing the homework, the assignment page stated that we should use SOCK_STREAM/IPPROTO_IP, which should actually be SOCK_RAW/IPPROTO_TCP. Figuring this out took a lot of reading random posts online, reading man pages of linux, going to office hours, innumerable amount of trial and error and just some pure luck. Based on my git repositery commit log, some 3~5 days went past between running into this problem and actually being able to resolve it. Figuring out the headers was challenging too, though the tutorials and the specs helped greatly, though it didn't take me long to realize that I thought I read the specs pretty carefully, but in reality I may have only understood/remembered/implemented 50% of what I need and the rest was filled in through painful debugging.

The next obstacle was a lot of misunderstandings of the spec files for IP and TCP compounded together. The bugs I remembered/logged in github commit include: 1) not realizing that the ack number should be the sequence number + payload size of the acked packet; 2) this is not a bug, but it took me a while to figure out that what I need to do to unpack the flags from the TCP header and the version/length from IP header is called bit masking; 3) there had been just a lot of problems back and forth with the ack/seq numbers, sometimes it even get messed up whether i'm using my ack or the received ack from server for certain things, because I named my variables terribly; 4) this is also not technically a bug but it took me a while to realize I should not keep using the same port for testing my code, because I was not handling connection teardown correctly, so I had to wait 5~10 minutes for the server to timeout and close the connection to test my code again, which did not work very well; 5) a lot of tutorials/online q&as are using eth0 for internet stuff, which in the current version of linux that we're using has been renamed to ens33 (in my personal opinion neither of the names make much sense, though eth0 seem slightly better). There were a lot more problems than these, but it's hard to remember them all. It's been some long weeks.

At the beginning of the last week, most of the code that needs to be there was there. However, due to a mixture of bad coding style, poor documentation and busy schedule, debugging the last few bugs turned out to be very very difficult. The two big bugs in this stage were: 1) padding the end of payload with 0 for calculation of checksum and not realizing I should take the 0 out before sending it, and 2) not realizing that I might get big packets, and set my maximum recv size to 4096. Other than that, I went through some stages of mixing my abstraction layers (handling some tcp data in my http_handle.py), and eventually decided that it made my code even more impossible to read and reverted it back to (more) clear seperation of layers. Regarding bug 1), I completely did not realize that by appending a 0 at the end of my http request, the server thought I had more data to send, and even when I sent a fin packet, it would still be potentially waiting to receive more data from me (or at least kept resending packets). It seemed like a trivial mistake, but completely confused the communication in a way that's not obvious to debug. I discovered it by painfully comparing the trace of telnet communication with server and my program communication with server, over and over again, and finally realized that the telnet GET request was one byte shorter than mine.

